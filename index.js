const { Client, GatewayIntentBits, EmbedBuilder, PermissionsBitField } = require('discord.js');
const { joinVoiceChannel, createAudioPlayer, createAudioResource, AudioPlayerStatus, StreamType, entersState, VoiceConnectionStatus } = require('@discordjs/voice');
const { exec, spawn } = require('child_process');
const ytSearch = require('youtube-search-api');
const playdl = require('play-dl');
const { promisify } = require('util');
const execAsync = promisify(exec);
const axios = require('axios');
const ytdl = require('ytdl-core');
require('dotenv').config();

// Config files
const playlists = require('./config/playlists');
const roastMessages = require('./config/roast-messages');
const megaRoastMessages = require('./config/mega-roast-messages');
const handlers = require('./handlers');

const client = new Client({
    intents: [
        GatewayIntentBits.Guilds,
        GatewayIntentBits.GuildMessages,
        GatewayIntentBits.MessageContent,
        GatewayIntentBits.GuildVoiceStates
    ]
});

// State management
const musicQueue = new Map();
const askLoopPlayed = new Set();
const askLoopActive = new Map();
const songAnalytics = new Map();
const realDurationCache = new Map();
const nsfwEnabled = new Map(); // guild -> boolean
const userStats = new Map(); // user -> {commandsUsed, favoriteCommand}

client.once('ready', () => {
    console.log(`ü§ñ Bot hazƒ±r! ${client.user.tag} olarak giri≈ü yapƒ±ldƒ±`);
    console.log('üî• Geli≈ümi≈ü Stream Sistemi aktif!');
    console.log('üß† No-Retry AI Modu √ßalƒ±≈üƒ±yor!');
    console.log('üßπ AI Cache temizlendi');
});

// Utility functions
function formatDuration(seconds) {
    const minutes = Math.floor(seconds / 60);
    const secs = seconds % 60;
    return `${minutes}:${secs.toString().padStart(2, '0')}`;
}

function parseDurationToSeconds(duration) {
    if (!duration || duration === 'Bilinmiyor') return 0;
    const parts = duration.split(':').map(p => parseInt(p, 10));
    if (parts.length === 2) {
        return parts[0] * 60 + parts[1];
    } else if (parts.length === 3) {
        return parts[0] * 3600 + parts[1] * 60 + parts[2];
    }
    return 0;
}

function extractVideoId(url) {
    const match = url.match(/(?:youtube\.com\/watch\?v=|youtu\.be\/)([^&\n?#]+)/);
    return match ? match[1] : null;
}

function updateRealDuration(videoId, actualDuration, expectedDuration) {
    if (!videoId || actualDuration < 5) return;
    
    const key = `duration_${videoId}`;
    const cached = realDurationCache.get(key);
    
    if (cached && Math.abs(cached.duration - actualDuration) < 3) {
        cached.confidence = Math.min(100, cached.confidence + 10);
        cached.lastUpdated = Date.now();
        return;
    }
    
    realDurationCache.set(key, {
        videoId,
        duration: actualDuration,
        expectedDuration,
        confidence: 40,
        accuracy: expectedDuration ? Math.round((actualDuration / expectedDuration) * 100) : 100,
        lastUpdated: Date.now()
    });
    
    if (realDurationCache.size > 1000) {
        const oldestEntries = Array.from(realDurationCache.entries())
            .sort((a, b) => a[1].lastUpdated - b[1].lastUpdated)
            .slice(0, 200);
        oldestEntries.forEach(([key]) => {
            realDurationCache.delete(key);
        });
    }
}

function getAIEstimatedDuration(song) {
    const videoId = extractVideoId(song.url);
    if (!videoId) return 0;
    
    const key = `duration_${videoId}`;
    const cached = realDurationCache.get(key);
    
    if (cached && cached.confidence > 60) {
        return cached.duration;
    }
    
    return parseDurationToSeconds(song.duration);
}

function analyzeCompletion(song, playedDuration, expectedDuration) {
    const finalExpectedDuration = getAIEstimatedDuration(song) || expectedDuration || playedDuration;
    
    const analytics = {
        song: song.title || 'Bilinmiyor',
        videoId: extractVideoId(song.url),
        playedDuration,
        expectedDuration: finalExpectedDuration,
        mode: 'No-Retry',
        reason: 'No-retry mod - Tek seferde kabul',
        percentage: finalExpectedDuration ? Math.round((playedDuration / finalExpectedDuration) * 100) : 100,
        confidence: 100
    };

    return analytics;
}

// Mesaj handler
client.on('messageCreate', async (message) => {
    if (message.author.bot) return;
    if (!message.content.startsWith('!')) return;

    const args = message.content.slice(1).trim().split(/ +/);
    const command = args.shift().toLowerCase();
    const serverQueue = musicQueue.get(message.guild.id);

    switch (command) {
        case 'askloop':
        case 'ask':
            await handleAskLoop(message, serverQueue);
            break;
        case 'play':
        case 'p':
            if (args.length === 0) {
                return message.reply('üéµ Kullanƒ±m: `!play ≈üarkƒ± adƒ±`');
            }
            await handlePlay(message, args.join(' '), serverQueue);
            break;
        case 'stop':
            await handleStop(message, serverQueue);
            break;
        case 'skip':
        case 's':
            await handleSkip(message, serverQueue);
            break;
        case 'ai':
            await handleAIStatus(message);
            break;
        case 'help':
        case 'h':
            await handleHelp(message);
            break;
        case 'test':
            if (args.length === 0) {
                return message.reply('üß™ Kullanƒ±m: `!test ≈üarkƒ± adƒ±` - Audio test i√ßin');
            }
            await handleTestSong(message, args.join(' '), serverQueue);
            break;
        // Eƒülence komutlarƒ±
        case 'meme':
            await handleMeme(message, args);
            break;
        case 'patlat': // rastgele diss/roast (SFW versiyon)
            await handlePatlat(message, args);
            break;
        case 'yazitura':
        case 'coin':
            await handleYaziTura(message);
            break;
        case 'kufur': // sans√ºrl√º, SFW k√ºf√ºr
            await handleKufur(message, args);
            break;
        case 'dogruluk':
            await handleDogruluk(message);
            break;
        case 'yalan':
            await handleYalan(message);
            break;
        case 'lovecalc':
        case 'askorani':
            await handleLoveCalc(message, args);
            break;
        case 'emoji':
            await handleEmojiMix(message, args);
            break;
        case 'zar':
        case 'dice':
            await handleZar(message, args);
            break;
        case 'espri':
            await handleEspri(message);
            break;
        case 'sarki': // eƒülence: playlistten rastgele isim √∂ner
            await handleSarkiOner(message);
            break;
        // Geli≈ümi≈ü oyun komutlarƒ±
        case 'oyunkesfet':
        case 'oyunara':
            await handlers.handleOyunKesfet(message, args);
            break;
        case 'oyunpuan':
        case 'gamerating':
            await handlers.handleOyunPuan(message, args);
            break;
        case 'oyuntur':
        case 'gamegenre':
            await handlers.handleOyunTur(message, args);
            break;
        // Geli≈ümi≈ü m√ºzik komutlarƒ±
        case 'queue':
        case 'kuyruk':
            await handlers.handleMusicQueue(message, serverQueue);
            break;
        case 'shuffle':
        case 'karistir':
            await handlers.handleShuffle(message, serverQueue);
            break;
        case 'repeat':
        case 'tekrar':
            await handlers.handleRepeat(message, serverQueue);
            break;
        case 'volume':
        case 'ses':
            await handlers.handleVolume(message, args, serverQueue);
            break;
        case 'nowplaying':
        case 'np':
            await handlers.handleNowPlaying(message, serverQueue);
            break;
        // Yeni g√∂rsel kategorileri
        case 'panda':
            await handlers.handleAnimalPic(message, 'panda');
            break;
        case 'fox':
        case 'tilki':
            await handlers.handleAnimalPic(message, 'fox');
            break;
        case 'bird':
        case 'kus':
            await handlers.handleAnimalPic(message, 'bird');
            break;
        case 'space':
        case 'uzay':
            await handlers.handleSpacePic(message);
            break;
        case 'nature':
        case 'doga':
            await handlers.handleNaturePic(message);
            break;
        case 'anime':
            await handleWaifuCategory(message, 'waifu');
            break;
        case 'manga':
            await handlers.handleMangaPic(message);
            break;
        // NSFW/Roast komutlarƒ±
        case 'nsfwtoggle':
            if (!message.member.permissions.has(PermissionsBitField.Flags.Administrator)) {
                return message.reply('Bu komutu sadece y√∂neticiler kullanabilir.');
            }
            const current = nsfwEnabled.get(message.guild.id) || false;
            nsfwEnabled.set(message.guild.id, !current);
            return message.reply(`NSFW modu: ${!current ? 'A√áIK' : 'KAPALI'}`);
        case 'roast':
            const targetUser = args.join(' ') || message.member.displayName;
            const allowNSFW = nsfwEnabled.get(message.guild.id) === true;
            const pool = allowNSFW ? [...roastMessages, ...megaRoastMessages.messages] : roastMessages.filter(m => !/\b(orospu|sik|am|g√∂t|kahpe|pezevenk)\b/i.test(m));
            const pick = pool[Math.floor(Math.random()*pool.length)];
            const line = pick.replace('{user}', targetUser);
            return message.reply(line);
        case 'roastme':
            const allowNSFWMe = nsfwEnabled.get(message.guild.id) === true;
            const poolMe = allowNSFWMe ? [...roastMessages, ...megaRoastMessages.messages] : roastMessages.filter(m => !/\b(orospu|sik|am|g√∂t|kahpe|pezevenk)\b/i.test(m));
            const pickMe = poolMe[Math.floor(Math.random()*poolMe.length)];
            const lineMe = pickMe.replace('{user}', message.member.displayName);
            return message.reply(lineMe);
        // Yeni yaratƒ±cƒ± komutlar
        case 'rastgele':
        case 'random':
            await handleRastgele(message, args);
            break;
        case 'nick':
        case 'nickname':
            await handleNickGenerator(message, args);
            break;
        case 'renk':
        case 'color':
            await handleColorGenerator(message);
            break;
        case 'kehanet':
        case 'fortune':
            await handleKehanet(message);
            break;
        case 'oyun':
        case 'game':
            await handleOyunOner(message);
            break;
        case 'fikir':
        case 'idea':
            await handleFikirOner(message);
            break;
        case 'ascii':
            await handleAsciiArt(message, args);
            break;
        case 'kelime':
        case 'word':
            await handleKelimeOyunu(message);
            break;
        case 'haiku':
            await handleHaiku(message);
            break;
        case 'rap':
            await handleRapBattle(message, args);
            break;
        // Yeni eƒülenceli sosyal komutlar
        case 'dogruya':
        case 'truthordare':
            await handleTruthOrDare(message, args);
            break;
        case 'kisilik':
        case 'personality':
            await handlePersonalityTest(message);
            break;
        case 'hikaye':
        case 'story':
            await handleStoryGenerator(message, args);
            break;
        case 'challenge':
        case 'meydan':
            await handleChallenge(message);
            break;
        case 'wouldyou':
        case 'tercihet':
            await handleWouldYouRather(message);
            break;
        case 'ship':
            await handleShip(message, args);
            break;
        case 'icerik':
        case 'content':
            await handleContentGenerator(message, args);
            break;
        case 'viral':
            await handleViralContent(message);
            break;
        case 'trend':
            await handleTrendyContent(message);
            break;
            // G√∂rsel/SFW image komutlarƒ±
            case 'kedi':
            case 'cat':
                await handleCat(message);
                break;
            case 'kopek':
            case 'dog':
                await handleDog(message);
                break;
            case 'waifu':
                await handleWaifuCategory(message, 'waifu');
                break;
            case 'neko':
                await handleWaifuCategory(message, 'neko');
                break;
            case 'hug':
            case 'saril':
                await handleWaifuCategory(message, 'hug');
                break;
            case 'kiss':
            case 'opus':
                await handleWaifuCategory(message, 'kiss');
                break;
            case 'patgif':
            case 'oksa':
                await handleWaifuCategory(message, 'pat');
                break;
            // NSFW G√∂rsel komutlarƒ± (Admin toggle gerekli)
            case 'nsfw':
            case 'nsfwimg':
                await handleNSFWImage(message);
                break;
            case 'erotic':
            case 'erotik':
                await handleEroticImage(message);
                break;
            case 'hentai':
                await handleHentaiImage(message);
                break;
            case 'r34':
            case 'rule34':
                await handleRule34Image(message);
                break;
            case 'nsfwwaifu':
                await handleNSFWWaifu(message);
                break;
            case 'nsfwneko':
                await handleNSFWNeko(message);
                break;
            case 'ecchi':
                await handleEcchiImage(message);
                break;
            default:
                await handleAskLoop(message, serverQueue);
                break;
     }
 });

// AI Status komutu
async function handleAIStatus(message) {
    const totalAnalytics = songAnalytics.size;
    if (totalAnalytics === 0) {
        return message.reply('ü§ñ Hen√ºz AI analiz verisi yok. Birka√ß ≈üarkƒ± √ßaldƒ±ktan sonra tekrar deneyin!');
    }

    const recentAnalytics = Array.from(songAnalytics.values()).slice(-10);
    const avgPercentage = Math.round(recentAnalytics.reduce((sum, a) => sum + a.percentage, 0) / recentAnalytics.length);

    const embed = new EmbedBuilder()
        .setColor('#00FF00')
        .setTitle('ü§ñ AI Analiz Raporu')
        .setDescription('**No-Retry AI sistemi √ßalƒ±≈üƒ±yor!**')
        .addFields([
            { 
                name: 'üìä Genel ƒ∞statistik', 
                value: `\`\`\`yaml\nToplam Analiz: ${totalAnalytics}\nMod: No-Retry\nBa≈üarƒ±: %100\`\`\``, 
                inline: false 
            },
            { 
                name: '‚è±Ô∏è Ortalama √áalma', 
                value: `\`%${avgPercentage}\``, 
                inline: true 
            },
            { 
                name: 'üéØ AI Durumu', 
                value: '`üü¢ No-Retry Aktif`', 
                inline: true 
            }
        ])
        .setFooter({ 
            text: 'üöÄ No-Retry AI Music System'
        })
        .setTimestamp();

    message.reply({ embeds: [embed] });
}

// ASK Loop handler
async function handleAskLoop(message, serverQueue) {
    const voiceChannel = message.member.voice.channel;
    if (!voiceChannel) {
        return message.reply('üîä Ses kanalƒ±nda deƒüilsin!');
    }

    console.log('üé∞ ASK Loop (No-Retry AI) ba≈ülatƒ±lƒ±yor...');

    if (!askLoopActive.has(message.guild.id)) {
        askLoopPlayed.clear();
        askLoopActive.set(message.guild.id, { 
            isActive: true, 
            startTime: Date.now(),
            songsPlayed: 0,
            totalPlayTime: 0,
            normalCompletions: 0
        });
    }

    // Random ≈üarkƒ± se√ß
    const availableSongs = playlists.askAcisi.filter(song => !askLoopPlayed.has(song));
    
    if (availableSongs.length === 0) {
        askLoopPlayed.clear();
        console.log('üîÑ ASK Loop: Liste sƒ±fƒ±rlanƒ±yor...');
        availableSongs.push(...playlists.askAcisi);
    }

    const randomSong = availableSongs[Math.floor(Math.random() * availableSongs.length)];
    askLoopPlayed.add(randomSong);

    try {
        console.log('üß† AI arama yapƒ±lƒ±yor:', randomSong);
        const searchResults = await ytSearch.GetListByKeyword(randomSong + ' official', false, 8);
        
        let bestVideo = searchResults.items?.[0];
        
        const song = {
            title: bestVideo ? bestVideo.title : randomSong,
            url: bestVideo ? `https://www.youtube.com/watch?v=${bestVideo.id}` : `https://www.youtube.com/results?search_query=${encodeURIComponent(randomSong)}`,
            duration: bestVideo ? (bestVideo.length?.simpleText || 'Bilinmiyor') : 'Bilinmiyor',
            thumbnail: bestVideo ? (bestVideo.thumbnail?.thumbnails?.[0]?.url || '') : '',
            requester: message.author,
            isAskLoop: true,
            searchQuery: randomSong
        };

        if (!serverQueue) {
            const queueConstruct = {
                textChannel: message.channel,
                voiceChannel: voiceChannel,
                connection: null,
                player: null,
                songs: [],
                volume: 5,
                playing: true,
                playerListenersSet: false,
                repeat: false,
                currentResource: null
            };

            musicQueue.set(message.guild.id, queueConstruct);
            queueConstruct.songs.push(song);

            try {
                const connection = joinVoiceChannel({
                    channelId: voiceChannel.id,
                    guildId: message.guild.id,
                    adapterCreator: message.guild.voiceAdapterCreator,
                });

                queueConstruct.connection = connection;
                queueConstruct.player = createAudioPlayer({
                    behaviors: {
                        noSubscriber: 'pause',
                        maxMissedFrames: Math.floor(15000 / 20)
                    }
                });

                connection.subscribe(queueConstruct.player);
                try {
                    await entersState(connection, VoiceConnectionStatus.Ready, 15000);
                } catch (e) {
                    console.warn('‚ö†Ô∏è Voice connection ready olmadƒ±, yine de denenecek:', e.message);
                }
                playSong(message.guild, queueConstruct.songs[0]);
            } catch (err) {
                console.log(err);
                musicQueue.delete(message.guild.id);
                return message.channel.send('‚ùå Voice channel baƒülantƒ± hatasƒ±!');
            }
        } else {
            console.log('üé∞ ASK Loop - yeni ≈üarkƒ± √ßalƒ±nƒ±yor...');
            serverQueue.songs = [song];
            playSong(message.guild, song);
        }

    } catch (error) {
        console.error('ASK Loop arama hatasƒ±:', error);
        return message.reply(`‚ùå ≈ûarkƒ± arama hatasƒ±: ${error.message}`);
    }
}

// Stop handler
async function handleStop(message, serverQueue) {
    if (!message.member.voice.channel) {
        return message.reply('üîä Ses kanalƒ±nda deƒüilsin!');
    }
    
    if (!serverQueue) {
        return message.reply('‚ùå √áalan ≈üarkƒ± yok!');
    }

    askLoopActive.delete(message.guild.id);
    askLoopPlayed.clear();
    
    serverQueue.songs = [];
    if (serverQueue.player) {
        serverQueue.player.stop();
    }
    if (serverQueue.connection) {
        serverQueue.connection.destroy();
    }
    musicQueue.delete(message.guild.id);
    
    return message.reply('‚èπÔ∏è M√ºzik durduruldu ve kuyruk temizlendi!');
}

// Skip handler
async function handleSkip(message, serverQueue) {
    if (!message.member.voice.channel) {
        return message.reply('üîä Ses kanalƒ±nda deƒüilsin!');
    }
    if (!serverQueue) {
        return message.reply('‚ùå √áalan ≈üarkƒ± yok!');
    }
    
    if (serverQueue.player) {
        serverQueue.player.stop();
    }
    return message.reply('‚è≠Ô∏è ≈ûarkƒ± atlandƒ±!');
}

// Play song function
async function playSong(guild, song) {
    const serverQueue = musicQueue.get(guild.id);
    let lastSourceProvider = null;
    let earlyRetryDone = false;

    if (!song) {
        if (askLoopActive.has(guild.id)) {
            console.log('üé∞ ASK Loop devam ediyor...');
            const fakeMessage = createFakeMessage(guild, serverQueue);
            return handleAskLoop(fakeMessage, serverQueue);
        }
        
        if (serverQueue.connection) {
            serverQueue.connection.destroy();
        }
        musicQueue.delete(guild.id);
        return;
    }

    console.log('üéµ ≈ûarkƒ± √ßalƒ±nƒ±yor:', song.title);
    
    try {
        let audioStream = null;
        let streamSource = 'unknown';
        
        try {
            console.log('üéÆ play-dl ile stream alƒ±nƒ±yor...');
            audioStream = await playdl.stream(song.url, { quality: 1 });
            streamSource = 'play-dl';
            lastSourceProvider = 'play-dl';
        } catch (error) {
            console.log('‚ö†Ô∏è play-dl ba≈üarƒ±sƒ±z, ytdl-core deneniyor...', error.message);
            try {
                const stream = ytdl(song.url, { 
                    filter: 'audioonly',
                    quality: 'lowestaudio',
                    highWaterMark: 1 << 25
                });
                audioStream = { stream: stream, type: StreamType.Arbitrary };
                streamSource = 'ytdl-core';
                lastSourceProvider = 'ytdl-core';
            } catch (ytdlError) {
                console.log('‚ö†Ô∏è ytdl-core ba≈üarƒ±sƒ±z, yt-dlp pipe deneniyor...', ytdlError.message);
                try {
                    const ytdlpProcess = spawn('yt-dlp', [
                        '-f', 'bestaudio[ext=m4a]/bestaudio[ext=webm]/bestaudio',
                        '-o', '-',
                        '--no-warnings',
                        '--no-call-home',
                        '--no-check-certificate',
                        '--prefer-free-formats',
                        '--youtube-skip-dash-manifest',
                        '--extract-flat',
                        '--no-playlist',
                        song.url
                    ], {
                        stdio: ['ignore', 'pipe', 'pipe']
                    });
                    
                    // Check if process started successfully
                    if (!ytdlpProcess.pid) {
                        throw new Error('yt-dlp process failed to start');
                    }
                    
                    audioStream = { stream: ytdlpProcess.stdout, type: StreamType.Arbitrary };
                    streamSource = 'yt-dlp-pipe';
                    lastSourceProvider = 'yt-dlp-pipe';
                    
                    ytdlpProcess.stderr.on('data', (data) => {
                        const errorMsg = data.toString();
                        if (errorMsg.includes('ERROR') || errorMsg.includes('WARNING')) {
                            console.log('üîß yt-dlp:', errorMsg.trim());
                        }
                    });
                    
                    ytdlpProcess.on('error', (error) => {
                        console.error('‚ùå yt-dlp process error:', error.message);
                    });
                    
                    ytdlpProcess.on('exit', (code) => {
                        if (code !== 0) {
                            console.log(`üîß yt-dlp process exited with code: ${code}`);
                        }
                    });
                    
                    console.log('‚úÖ yt-dlp pipe stream ba≈ülatƒ±ldƒ±');
                } catch (ytdlpError) {
                    console.error('‚ùå T√ºm stream y√∂ntemleri ba≈üarƒ±sƒ±z:', ytdlpError.message);
                    throw new Error('Stream alƒ±namadƒ±');
                }
            }
        }

        const resource = createAudioResource(audioStream.stream, {
            inputType: audioStream.type,
            inlineVolume: true,
            silencePaddingFrames: 5
        });
        
        if (resource.volume) {
            resource.volume.setVolume((serverQueue.volume || 5) / 10);
        }
        serverQueue.currentResource = resource;

        if (!serverQueue.playerListenersSet) {
            serverQueue.player.on('stateChange', (oldState, newState) => {
                console.log(`üé≠ Player: ${oldState.status} -> ${newState.status}`);
            });

            serverQueue.player.on(AudioPlayerStatus.Idle, () => {
                // Use tracked start timestamp to compute how long the song actually played
                const startTs = serverQueue._playStart || Date.now();
                const playedDuration = Math.floor((Date.now() - startTs) / 1000);
                const expectedDuration = getAIEstimatedDuration(song) || parseDurationToSeconds(song.duration);
                
                console.log(`‚èπÔ∏è ≈ûarkƒ± sona erdi: ${playedDuration}s √ßalƒ±ndƒ± (beklenen: ${expectedDuration}s)`);
                
                // Early end retry logic
                if (playedDuration < 5 && !earlyRetryDone && expectedDuration > 10) {
                    console.log('üîÑ Erken biti≈ü tespit edildi, alternatif source ile yeniden denenecek...');
                    earlyRetryDone = true;
                    
                    // Switch to alternative source
                    const alternativeSource = lastSourceProvider === 'play-dl' ? 'ytdl-core' : 
                                            lastSourceProvider === 'ytdl-core' ? 'yt-dlp-pipe' : 'play-dl';
                    console.log(`üîÄ ${lastSourceProvider} -> ${alternativeSource} deƒüi≈üimi yapƒ±lƒ±yor...`);
                    
                    setTimeout(() => {
                        playSong(guild, song);
                    }, 1000);
                    return;
                }
                
                const analytics = analyzeCompletion(song, playedDuration, expectedDuration);
                songAnalytics.set(`${Date.now()}_${song.title}`, analytics);
                
                updateRealDuration(extractVideoId(song.url), playedDuration, expectedDuration);
                
                if (serverQueue.repeat && serverQueue.songs[0]) {
                    // Tekrar modu aktifse aynƒ± ≈üarkƒ±yƒ± yeniden √ßal
                    playSong(guild, serverQueue.songs[0]);
                } else {
                    serverQueue.songs.shift();
                    playSong(guild, serverQueue.songs[0]);
                }
            });

            serverQueue.player.on('error', error => {
                console.error('‚ùå Audio player hatasƒ±:', error);
                serverQueue.songs.shift();
                playSong(guild, serverQueue.songs[0]);
            });

            serverQueue.playerListenersSet = true;
        }

        // Track when we start playing this resource for analytics and retry logic
        serverQueue._playStart = Date.now();
        serverQueue.player.play(resource);
        sendNowPlayingMessage(serverQueue);

    } catch (error) {
        console.error(`‚ùå ≈ûarkƒ± √ßalma hatasƒ±: ${error.message}`);
        serverQueue.textChannel.send(`‚ùå ≈ûarkƒ± √ßalƒ±namadƒ±: **${song.title}**`);
        serverQueue.songs.shift();
        playSong(guild, serverQueue.songs[0]);
    }
}

function createFakeMessage(guild, serverQueue) {
    return {
        guild: guild,
        member: { voice: { channel: serverQueue.voiceChannel } },
        channel: serverQueue.textChannel,
        author: { bot: false }
    };
}

function sendNowPlayingMessage(serverQueue) {
    if (!serverQueue.songs[0]) return;
    
    const song = serverQueue.songs[0];
    const embed = new EmbedBuilder()
        .setColor('#00FF00')
        .setTitle('üéµ ≈ûu An √áalƒ±yor')
        .setDescription(`**${song.title}**`)
        .addFields([
            { name: '‚è±Ô∏è S√ºre', value: song.duration || 'Bilinmiyor', inline: true },
            { name: 'üë§ ƒ∞steyen', value: song.requester.username, inline: true },
            { name: 'üéØ Mod', value: song.isAskLoop ? 'ASK Loop' : 'Manuel', inline: true }
        ])
        .setFooter({ text: 'üöÄ No-Retry AI Music System' })
        .setTimestamp();

    if (song.thumbnail) {
        embed.setThumbnail(song.thumbnail);
    }

    serverQueue.textChannel.send({ embeds: [embed] });
}

async function handlePlay(message, query, serverQueue) {
    const voiceChannel = message.member.voice.channel;
    if (!voiceChannel) {
        return message.reply('üîä Ses kanalƒ±nda deƒüilsin!');
    }

    console.log('üîç ≈ûarkƒ± aranƒ±yor:', query);

    try {
        const searchResults = await ytSearch.GetListByKeyword(query + ' official', false, 8);
        
        if (!searchResults || !searchResults.items || searchResults.items.length === 0) {
            return message.reply('‚ùå ≈ûarkƒ± bulunamadƒ±!');
        }

        let bestVideo = searchResults.items[0];

        const song = {
            title: bestVideo.title,
            url: `https://www.youtube.com/watch?v=${bestVideo.id}`,
            duration: bestVideo.length?.simpleText || 'Bilinmiyor',
            thumbnail: bestVideo.thumbnail?.thumbnails?.[0]?.url || '',
            requester: message.author,
            isAskLoop: false,
            searchQuery: query
        };

        if (!serverQueue) {
            const queueConstruct = {
                textChannel: message.channel,
                voiceChannel: voiceChannel,
                connection: null,
                player: null,
                songs: [],
                volume: 5,
                playing: true,
                playerListenersSet: false,
                repeat: false,
                currentResource: null
            };

            musicQueue.set(message.guild.id, queueConstruct);
            queueConstruct.songs.push(song);

            try {
                const connection = joinVoiceChannel({
                    channelId: voiceChannel.id,
                    guildId: message.guild.id,
                    adapterCreator: message.guild.voiceAdapterCreator,
                });

                queueConstruct.connection = connection;
                queueConstruct.player = createAudioPlayer({
                    behaviors: {
                        noSubscriber: 'pause',
                        maxMissedFrames: Math.floor(15000 / 20)
                    }
                });

                connection.subscribe(queueConstruct.player);
                try {
                    await entersState(connection, VoiceConnectionStatus.Ready, 15000);
                } catch (e) {
                    console.warn('‚ö†Ô∏è Voice connection ready olmadƒ±, yine de denenecek:', e.message);
                }
                playSong(message.guild, queueConstruct.songs[0]);
            } catch (err) {
                console.log(err);
                musicQueue.delete(message.guild.id);
                return message.channel.send('‚ùå Voice channel baƒülantƒ± hatasƒ±!');
            }
        } else {
            serverQueue.songs.push(song);
            return message.reply(`‚úÖ **${song.title}** kuyruƒüa eklendi!`);
        }

    } catch (error) {
        console.error('Play komutu hatasƒ±:', error);
        return message.reply(`‚ùå ≈ûarkƒ± arama hatasƒ±: ${error.message}`);
    }
}

async function handleHelp(message) {
    const embed = new EmbedBuilder()
        .setColor('#0099ff')
        .setTitle('ü§ñ Bot Komutlarƒ±')
        .setDescription('**Mevcut komutlarƒ±n listesi:**')
        .addFields([
            { 
                name: 'üéµ M√ºzik Komutlarƒ±', 
                value: '`!play <≈üarkƒ±>` - ≈ûarkƒ± √ßal\n`!askloop` - ASK acƒ±sƒ± √ßal\n`!stop` - M√ºziƒüi durdur\n`!skip` - ≈ûarkƒ±yƒ± atla\n`!queue/!kuyruk` - Kuyruƒüu g√∂ster\n`!shuffle/!karistir` - Karƒ±≈ütƒ±r\n`!repeat/!tekrar` - Tekrar modu\n`!volume/!ses <0-10>` - Ses\n`!nowplaying/!np` - ≈ûu an √ßalan', 
                inline: false 
            },
            { 
                name: 'ü§ñ AI Komutlarƒ±', 
                value: '`!ai` - AI durumu\n`!help` - Yardƒ±m\n`!test <≈üarkƒ±>` - Audio test', 
                inline: false 
            },
            { 
                name: 'üé≤ Eƒülence Komutlarƒ±', 
                value: '`!meme` - Rastgele meme\n`!patlat` - SFW roast\n`!yazitura` - Yazƒ± tura\n`!kufur` - Sans√ºrl√º k√ºf√ºr\n`!dogruluk` - Doƒüruluk sorusu\n`!yalan` - Yalan ifade\n`!lovecalc` - A≈ük hesaplama\n`!emoji` - Emoji karƒ±≈üƒ±mƒ±\n`!zar` - Zar atma\n`!espri` - Espri\n`!sarki` - ≈ûarkƒ± √∂nerisi\n`!oyunkesfet/!oyunara <kelime>` - Oyun ke≈üfet\n`!oyunpuan <oyun>` - Oyun puanƒ±\n`!oyuntur <kategori>` - Oyun t√ºrleri', 
                inline: false 
            },
            { 
                name: 'üî• NSFW/Roast Komutlarƒ±', 
                value: '`!nsfwtoggle` - NSFW a√ß/kapat (Admin)\n`!roast <ki≈üi>` - Roast mesajƒ±\n`!roastme` - Kendini roast et\n\nNSFW g√∂rsel komutlarƒ± (admin a√ßarsa): `!nsfw`, `!erotic`, `!hentai`, `!r34`, `!nsfwwaifu`, `!nsfwneko`, `!ecchi`\nSFW alternatifler: `!waifu`, `!neko`, `!hug`, `!kiss`, `!patgif`, `!kedi`, `!kopek`', 
                inline: false 
            },
            { 
                name: 'üåü Yaratƒ±cƒ± Komutlar', 
                value: '`!rastgele` - Rastgele i√ßerik\n`!nick` - Nick √∂nerisi\n`!renk` - Renk √ºreteci\n`!kehanet` - Kehanet\n`!oyun` - Oyun √∂nerisi\n`!fikir` - Yaratƒ±cƒ± fikir\n`!ascii <metin>` - ASCII art\n`!kelime` - Kelime oyunu\n`!haiku` - Haiku ≈üiiri\n`!rap <tema>` - Rap battle', 
                inline: false 
            },
            { 
                name: 'üì∑ G√∂rsel/SFW ƒ∞√ßerik', 
                value: '`!kedi/!cat` - Sevimli kedi resmi\n`!kopek/!dog` - K√∂pek resmi\n`!waifu` - Anime kƒ±zƒ±\n`!neko` - Neko kedi kƒ±zƒ±\n`!hug/!saril` - Sarƒ±lma GIF\n`!kiss/!opus` - √ñp√ºc√ºk GIF\n`!patgif/!oksa` - Ok≈üama GIF\n`!panda` - Panda\n`!fox/!tilki` - Tilki\n`!bird/!kus` - Ku≈ü\n`!space/!uzay` - Uzay\n`!nature/!doga` - Doƒüa\n`!anime` - Anime stili\n`!manga` - Manga stili', 
                inline: false 
            }
        ])
        .setFooter({ text: 'üöÄ No-Retry AI Music System | Eƒülence Paketleri' })
        .setTimestamp();

    message.reply({ embeds: [embed] });
}

client.login(process.env.DISCORD_TOKEN);

async function handleTestSong(message, query, serverQueue) {
    const voiceChannel = message.member.voice.channel;
    if (!voiceChannel) {
        return message.reply('üîä Ses kanalƒ±nda deƒüilsin!');
    }

    console.log('üß™ TEST MODE - ≈ûarkƒ± aranƒ±yor:', query);

    try {
        const searchResults = await ytSearch.GetListByKeyword(query + ' official', false, 8);
        
        if (!searchResults || !searchResults.items || searchResults.items.length === 0) {
            return message.reply('‚ùå Test ≈üarkƒ±sƒ± bulunamadƒ±!');
        }

        let bestVideo = searchResults.items[0];

        const song = {
            title: '[TEST] ' + bestVideo.title,
            url: `https://www.youtube.com/watch?v=${bestVideo.id}`,
            duration: bestVideo.length?.simpleText || 'Bilinmiyor',
            thumbnail: bestVideo.thumbnail?.thumbnails?.[0]?.url || '',
            requester: message.author,
            isAskLoop: false,
            isTest: true,
            searchQuery: query
        };

        if (!serverQueue) {
            const queueConstruct = {
                textChannel: message.channel,
                voiceChannel: voiceChannel,
                connection: null,
                player: null,
                songs: [],
                volume: 5,
                playing: true,
                playerListenersSet: false,
                repeat: false,
                currentResource: null
            };

            musicQueue.set(message.guild.id, queueConstruct);
            queueConstruct.songs.push(song);

            try {
                const connection = joinVoiceChannel({
                    channelId: voiceChannel.id,
                    guildId: message.guild.id,
                    adapterCreator: message.guild.voiceAdapterCreator,
                });

                queueConstruct.connection = connection;
                queueConstruct.player = createAudioPlayer({
                    behaviors: {
                        noSubscriber: 'pause',
                        maxMissedFrames: Math.floor(15000 / 20)
                    }
                });

                connection.subscribe(queueConstruct.player);
                playSong(message.guild, queueConstruct.songs[0]);
            } catch (err) {
                console.log(err);
                musicQueue.delete(message.guild.id);
                return message.channel.send('‚ùå Voice channel baƒülantƒ± hatasƒ±!');
            }
        } else {
            serverQueue.songs.push(song);
            return message.reply(`üß™ **TEST: ${song.title}** kuyruƒüa eklendi!`);
        }

    } catch (error) {
        console.error('Test komutu hatasƒ±:', error);
        return message.reply(`‚ùå Test ≈üarkƒ±sƒ± arama hatasƒ±: ${error.message}`);
    }
}


async function handlePatlat(message, args) {
    const target = args.join(' ') || message.member.displayName;
    const sfwRoasts = roastMessages.filter(m => !/\b(orospu|sik|am|g√∂t|kahpe|pezevenk)\b/i.test(m));
    const roast = sfwRoasts[Math.floor(Math.random() * sfwRoasts.length)];
    const finalRoast = roast.replace('{user}', target);
    await message.reply(`üî• ${finalRoast}`);
}

async function handleYaziTura(message) {
    const result = Math.random() < 0.5 ? 'YAZI' : 'TURA';
    await message.reply(`ü™ô **${result}**`);
}

async function handleKufur(message, args) {
    const target = args.join(' ') || 'birisi';
    const kufurler = [
        `${target} √ßok salak ya!`,
        `Vay be ${target}, kafan g√ºzel √ßalƒ±≈üƒ±yor!`,
        `${target} tam bir dingil!`,
        `E hadi ${target}, beynini kullan!`,
        `${target} kafayƒ± mƒ± yedin sen?`
    ];
    const pick = kufurler[Math.floor(Math.random() * kufurler.length)];
    await message.reply(`ü§¨ ${pick}`);
}

async function handleDogruluk(message) {
    const dogruluklar = [
        'Su aslƒ±nda ya≈ü deƒüil, ƒ±slaktƒ±r.',
        'Pizza √º√ßgen ama kutusu kare.',
        'Hi√ß kimse bug√ºnden √∂nce yarƒ±nƒ± g√∂rmedi.',
        'Aynada kendini g√∂r√ºrs√ºn ama sen ayna deƒüilsin.',
        'Her dakika 60 saniyedir.'
    ];
    const pick = dogruluklar[Math.floor(Math.random() * dogruluklar.length)];
    await message.reply(`‚ú® ${pick}`);
}

async function handleYalan(message) {
    const yalanlar = [
        'Kediler aslƒ±nda k√∂peklerin evrimle≈ümi≈ü halidir.',
        'WiFi √ßok kullanƒ±rsan internetten d√º≈üersin.',
        'Telefonu ≈üarja takƒ±lƒ± bƒ±rakƒ±rsan patlayabilir.',
        'Gece ƒ±slƒ±k √ßalarsan ruh √ßaƒüƒ±rƒ±rsƒ±n.',
        'Sakƒ±z yutarsan midende 7 yƒ±l kalƒ±r.'
    ];
    const pick = yalanlar[Math.floor(Math.random() * yalanlar.length)];
    await message.reply(`ü§• ${pick}`);
}

async function handleLoveCalc(message, args) {
    if (args.length < 2) {
        return message.reply('üíï Kullanƒ±m: `!lovecalc ki≈üi1 ki≈üi2`');
    }
    const person1 = args[0];
    const person2 = args.slice(1).join(' ');
    const percentage = Math.floor(Math.random() * 101);
    
    let description = '';
    if (percentage < 30) description = 'Hmm, pek uyumlu g√∂r√ºnm√ºyorsuz...';
    else if (percentage < 60) description = 'Fena deƒüil, belki bir ≈üans verebilirsiniz!';
    else if (percentage < 85) description = 'Vay be! G√ºzel bir uyum var burada!';
    else description = 'PERFECT MATCH! üî•üíï';
    
    await message.reply(`üíñ **${person1}** & **${person2}**\n‚ù§Ô∏è A≈ük Oranƒ±: **%${percentage}**\n${description}`);
}

async function handleEmojiMix(message, args) {
    const emojis = ['üòÄ', 'ÔøΩÔøΩÔøΩ2', 'ü•∞', 'üòé', 'ü§î', 'üò¥', 'ü§Ø', 'ü•≥', 'üòá', 'ü§™', 'ü§†', 'ü•∂', 'üî•', 'üíØ', '‚ú®', 'üåü', 'üíñ', 'üéµ', 'üéâ', 'üöÄ'];
    const mixed = [];
    for (let i = 0; i < 5; i++) {
        mixed.push(emojis[Math.floor(Math.random() * emojis.length)]);
    }
    await message.reply(`üé≠ Emoji Karƒ±≈üƒ±mƒ±n: ${mixed.join(' ')}`);
}

async function handleZar(message, args) {
    const sides = args[0] ? parseInt(args[0]) : 6;
    if (sides < 2 || sides > 100) {
        return message.reply('üé≤ Zar y√ºz√º sayƒ±sƒ± 2-100 arasƒ± olmalƒ±!');
    }
    const result = Math.floor(Math.random() * sides) + 1;
    await message.reply(`üé≤ ${sides} y√ºzl√º zar: **${result}**`);
}

async function handleEspri(message) {
    const jokes = [
        'Balƒ±k ne zaman konu≈üur? Suda.',
        'Hangi hayvan en √ßok uyur? Uyku-≈üu!',
        'Doktorlar neden kalem kullanƒ±r? √á√ºnk√º onlar iyile≈ütirirler!',
        'Neden telefon √ßaldƒ±? √á√ºnk√º a√ßƒ±ktaydƒ±!',
        'Hangi meyve en √ßok ko≈üar? Elma, √ß√ºnk√º vitamin C!'
    ];
    const pick = jokes[Math.floor(Math.random() * jokes.length)];
    await message.reply(`ü§£ ${pick}`);
}

async function handleSarkiOner(message) {
    const list = playlists.askAcisi || [];
    if (!list.length) return message.reply('Liste bo≈ü gibi g√∂r√ºn√ºyor.');
    const pick = list[Math.floor(Math.random() * list.length)];
    await message.reply(`üéß Rastgele √∂neri: **${pick}**`);
}

// Yeni yaratƒ±cƒ± komut handlers
async function handleRastgele(message, args) {
    const categories = {
        sayi: () => Math.floor(Math.random() * 1000) + 1,
        renk: () => '#' + Math.floor(Math.random()*16777215).toString(16),
        hayvan: () => ['Kedi', 'K√∂pek', 'Aslan', 'Kaplan', 'Fil', 'Zebra', 'Giraffe', 'Panda'][Math.floor(Math.random() * 8)],
        yemek: () => ['Pizza', 'Burger', 'Kebab', 'Makarna', 'Sushi', 'Dondurma', '√áikolata', 'Baklava'][Math.floor(Math.random() * 8)],
        √ºlke: () => ['T√ºrkiye', 'Amerika', 'Japonya', 'Almanya', 'Fransa', 'ƒ∞talya', 'ƒ∞spanya', 'Brezilya'][Math.floor(Math.random() * 8)]
    };
    
    const category = args[0] || Object.keys(categories)[Math.floor(Math.random() * Object.keys(categories).length)];
    
    if (categories[category]) {
        const result = categories[category]();
        await message.reply(`üé≤ Rastgele **${category}**: **${result}**`);
    } else {
        await message.reply(`üé≤ Mevcut kategoriler: ${Object.keys(categories).join(', ')}`);
    }
}

async function handleNickGenerator(message, args) {
    const adjectives = ['Cool', 'Epic', 'Legendary', 'Shadow', 'Fire', 'Ice', 'Dark', 'Bright', 'Swift', 'Silent'];
    const nouns = ['Wolf', 'Dragon', 'Phoenix', 'Tiger', 'Eagle', 'Warrior', 'Hunter', 'Master', 'Knight', 'Ninja'];
    const numbers = Math.floor(Math.random() * 999) + 1;
    
    const nick = `${adjectives[Math.floor(Math.random() * adjectives.length)]}${nouns[Math.floor(Math.random() * nouns.length)]}${numbers}`;
    
    await message.reply(`üè∑Ô∏è √ñneri Nick: **${nick}**`);
}

async function handleColorGenerator(message) {
    const color = '#' + Math.floor(Math.random()*16777215).toString(16);
    const embed = new EmbedBuilder()
        .setColor(color)
        .setTitle('üé® Rastgele Renk')
        .setDescription(`**${color.toUpperCase()}**`)
        .addFields([
            { name: 'Hex Kod', value: color.toUpperCase(), inline: true },
            { name: 'RGB', value: `(${parseInt(color.slice(1,3), 16)}, ${parseInt(color.slice(3,5), 16)}, ${parseInt(color.slice(5,7), 16)})`, inline: true }
        ]);
    
    await message.reply({ embeds: [embed] });
}

async function handleKehanet(message) {
    const kehanetler = [
        'Yakƒ±nda b√ºy√ºk bir deƒüi≈üiklik ya≈üayacaksƒ±n.',
        'Bug√ºn sana g√ºzel bir haber gelecek.',
        'Dikkatli ol, etrafƒ±nda seni seven biri var.',
        '≈ûansƒ±n yolda, sabƒ±rlƒ± ol.',
        'Ge√ßmi≈üten birisi hayatƒ±na geri d√∂necek.',
        'Maddi bir kazan√ß elde edeceksin.',
        'Yeni bir arkada≈ülƒ±k kurulacak.',
        'Saƒülƒ±ƒüƒ±na dikkat et, dinlenmen gerek.',
        'A≈ük kapƒ±nƒ± √ßalƒ±yor.',
        'Bir sƒ±rrƒ±n ortaya √ßƒ±kacak.'
    ];
    
    const kehanet = kehanetler[Math.floor(Math.random() * kehanetler.length)];
    await message.reply(`üîÆ **Kehanet:** ${kehanet}`);
}

async function handleOyunOner(message) {
    const oyunlar = [
        'Among Us', 'Minecraft', 'Valorant', 'CS:GO', 'Fortnite', 'League of Legends', 
        'Fall Guys', 'Rocket League', 'Apex Legends', 'Overwatch', 'PUBG', 'Roblox',
        'GTA V', 'Red Dead Redemption 2', 'Cyberpunk 2077', 'The Witcher 3'
    ];
    
    const oyun = oyunlar[Math.floor(Math.random() * oyunlar.length)];
    await message.reply(`üéÆ Oyun √ñnerisi: **${oyun}**`);
}

async function handleFikirOner(message) {
    const fikirler = [
        'Bug√ºn yeni bir hobi edin!',
        'Eski bir arkada≈üƒ±na mesaj at.',
        'Bir kitap okumaya ba≈üla.',
        'Y√ºr√ºy√º≈ü yapmaya √ßƒ±k.',
        'Yeni bir yemek tarifi dene.',
        'Odanƒ± yeniden d√ºzenle.',
        'Bir film izle.',
        'M√ºzik dinleyerek dans et.',
        'Kedilerle oyna.',
        'G√ºnl√ºk tutmaya ba≈üla.',
        'Bir online kurs al.',
        'Bah√ßƒ±vanlƒ±k yap.',
        'Fotoƒüraf √ßekmeye √ßƒ±k.',
        'Puzzle √ß√∂z.',
        'Arkada≈ülarƒ±nla oyun oyna.'
    ];
    
    const fikir = fikirler[Math.floor(Math.random() * fikirler.length)];
    await message.reply(`üí° **Yaratƒ±cƒ± Fikir:** ${fikir}`);
}

async function handleAsciiArt(message, args) {
    if (!args.length) {
        return message.reply('üìù Kullanƒ±m: `!ascii <metin>`');
    }
    
    const text = args.join(' ').toUpperCase();
    if (text.length > 10) {
        return message.reply('‚ö†Ô∏è Metin 10 karakterden kƒ±sa olmalƒ±!');
    }
    
    // Basit ASCII art (sadece A-Z i√ßin)
    const ascii = {
        'A': ['  A  ', ' A A ', 'AAAAA', 'A   A', 'A   A'],
        'B': ['BBBB ', 'B   B', 'BBBB ', 'B   B', 'BBBB '],
        'C': [' CCC ', 'C    ', 'C    ', 'C    ', ' CCC '],
        'D': ['DDDD ', 'D   D', 'D   D', 'D   D', 'DDDD '],
        'E': ['EEEEE', 'E    ', 'EEE  ', 'E    ', 'EEEEE'],
        'O': [' OOO ', 'O   O', 'O   O', 'O   O', ' OOO '],
        'L': ['L    ', 'L    ', 'L    ', 'L    ', 'LLLLL'],
        ' ': ['     ', '     ', '     ', '     ', '     ']
    };
    
    let result = ['', '', '', '', ''];
    for (let char of text) {
        if (ascii[char]) {
            for (let i = 0; i < 5; i++) {
                result[i] += ascii[char][i] + ' ';
            }
        }
    }
    
    await message.reply('```\n' + result.join('\n') + '\n```');
}

async function handleKelimeOyunu(message) {
    const kelimeler = [
        'JAVASCRIPT', 'DISCORD', 'MUZIK', 'OYUN', 'BILGISAYAR', 'TELEFON', 'INTERNET', 'PROGRAM',
        'WEBSITE', 'YOUTUBE', 'INSTAGRAM', 'FACEBOOK', 'TWITTER', 'GOOGLE', 'APPLE', 'MICROSOFT'
    ];
    
    const kelime = kelimeler[Math.floor(Math.random() * kelimeler.length)];
    const harfler = kelime.split('').sort(() => Math.random() - 0.5);
    
    await message.reply(`üî§ **Kelime Oyunu!**\nBu harflerden hangi kelime olu≈üur?\n\`${harfler.join(' ')}\`\n\n*ƒ∞pucu: ${kelime.length} harfli*`);
}

async function handleHaiku(message) {
    const haiku = [
        'Sabah r√ºzgarƒ±\nYapraƒüƒ± usulca dans\nEttirir, huzur',
        'Kedi miyavlar\nPencerede g√ºne≈ü var\nUykuya dalƒ±r',
        'Yaƒümur damlalarƒ±\nCamda iz bƒ±rakarak\nAkar, sessizce',
        'M√ºzik √ßalarken\nKalp ritmi hƒ±zlanƒ±r\nDans eder ruh',
        'Kahve kokusu\nSabah uyanƒ±≈üƒ±mƒ±\nTatlƒ± kƒ±lar √ßok'
    ];
    
    const selectedHaiku = haiku[Math.floor(Math.random() * haiku.length)];
    await message.reply(`üå∏ **Haiku:**\n\`\`\`\n${selectedHaiku}\n\`\`\``);
}

async function handleRapBattle(message, args) {
    const tema = args.join(' ') || 'genel';
    
    const rapLines = [
        `Yo, ${message.author.username} burada, flow\'um var`,
        `${tema} hakkƒ±nda rap yapƒ±yorum, dinle ne var`,
        'Mikrofonu kap, beat\'i a√ß, ba≈ülasƒ±n show',
        'Discord\'da rap battle, bu bizim flow',
        'Kelimeler akƒ±yor sanki nehir gibi',
        'Ritim tutuyorum, kalp gibi',
        'Bu server\'da efsane olacaƒüƒ±m',
        'Herkesi ge√ßeceƒüim, birinci olacaƒüƒ±m'
    ];
    
    const selectedLines = [];
    for (let i = 0; i < 4; i++) {
        selectedLines.push(rapLines[Math.floor(Math.random() * rapLines.length)]);
    }
    
    await message.reply(`üé§ **Rap Battle - ${tema}:**\n\`\`\`\n${selectedLines.join('\n')}\n\`\`\``);
}

async function handleTruthOrDare(message, args) {
    const mode = (args[0] || '').toLowerCase();
    const truths = [
        'En utan√ß verici anƒ±n neydi?',
        'Hi√ß kimseye s√∂ylemediƒüin bir sƒ±rrƒ±n var mƒ±?',
        'Birinden gizlediƒüin en b√ºy√ºk ≈üey ne?',
        'A≈üƒ±k olup da s√∂yleyemediƒüin oldu mu?',
        'Bug√ºne kadar yaptƒ±ƒüƒ±n en komik ≈üey ne?'
    ];
    const dares = [
        'Profil fotoƒürafƒ±nƒ± 10 dakika boyunca komik bir ≈üeye deƒüi≈ütir.',
        'Sunucuda birine √∂vg√º yaz.',
        'En sevdiƒüin ≈üarkƒ±yƒ± caps lock ile yaz.',
        'Bir emoji ile kendini anlatmaya √ßalƒ±≈ü.',
        'Rastgele biriyle 3 c√ºmlelik mini hikaye yaz.'
    ];
    if (mode === 'truth' || mode === 'dogru') {
        const t = truths[Math.floor(Math.random() * truths.length)];
        return message.reply(`üßê Doƒüruluk: ${t}`);
    }
    if (mode === 'dare' || mode === 'cesaret') {
        const d = dares[Math.floor(Math.random() * dares.length)];
        return message.reply(`üí™ Cesaret: ${d}`);
    }
    const pick = Math.random() < 0.5 ? `üßê Doƒüruluk: ${truths[Math.floor(Math.random() * truths.length)]}` : `üí™ Cesaret: ${dares[Math.floor(Math.random() * dares.length)]}`;
    await message.reply(pick);
}

async function handlePersonalityTest(message) {
    const types = [
        'Stratejist üß†', 'Macera Ruhlu üß≠', 'Lider ü¶Å', 'Sanat√ßƒ± üé®', 'Bilge üßô‚Äç‚ôÇÔ∏è',
        'Ne≈üeli üòÑ', 'Analitik üìä', 'Sakin üåø', 'Yaratƒ±cƒ± üí°', 'Karizmatik ‚ú®'
    ];
    const result = types[Math.floor(Math.random() * types.length)];
    await message.reply(`üß© Ki≈üilik Testi Sonucun: **${result}**`);
}

async function handleStoryGenerator(message, args) {
    const tema = args.join(' ') || 'm√ºthi≈ü bir macera';
    const starters = [
        'Bir zamanlar uzak bir diyarda',
        'Gece yarƒ±sƒ± sessizlik √ß√∂kerken',
        'Kalabalƒ±k bir ≈üehirde yalnƒ±z y√ºr√ºrken',
        'Eski bir defterin sayfalarƒ± arasƒ±nda',
        'Bir yaƒümur damlasƒ±nƒ±n pe≈üinden'
    ];
    const twists = [
        'beklenmedik bir kapƒ± a√ßƒ±ldƒ±',
        'gizemli bir not bulundu',
        'zaman aniden yava≈üladƒ±',
        'bir k√∂pek yolu g√∂sterdi',
        'bir ≈üarkƒ± her ≈üeyi deƒüi≈ütirdi'
    ];
    const endings = [
        've o g√ºn her ≈üey yeni ba≈üladƒ±.',
        'ama esas macera ≈üimdi ba≈ülƒ±yordu.',
        've artƒ±k hi√ßbir ≈üey eskisi gibi olmayacaktƒ±.',
        've dostluk her ≈üeyi kazandƒ±.',
        've kahramanƒ±mƒ±z yeni bir yol se√ßti.'
    ];
    const story = `${starters[Math.floor(Math.random()*starters.length)]} ${tema} √ºzerine ${twists[Math.floor(Math.random()*twists.length)]} ve ${endings[Math.floor(Math.random()*endings.length)]}`;
    await message.reply(`üìñ Hikaye: ${story}`);
}

async function handleChallenge(message) {
    const challenges = [
        'Sunucuda 3 farklƒ± ki≈üiye √∂vg√º yaz.',
        'Profiline 1 saatliƒüine bir emojiyi ekle.',
        'Rastgele bir emoji ile 3 c√ºmle kur.',
        'En sevdiƒüin ≈üarkƒ±yƒ± payla≈ü.',
        'Son √ßektiƒüin fotoƒürafƒ± (SFW) hashtag ile anlat.'
    ];
    const c = challenges[Math.floor(Math.random()*challenges.length)];
    await message.reply(`üèÅ Meydan Okuma: ${c}`);
}

async function handleWouldYouRather(message) {
    const pairs = [
        ['G√∂r√ºnmez olmak', 'Zihin okumak'],
        ['U√ßmak', 'I≈üƒ±nlanmak'],
        ['Ge√ßmi≈üe gitmek', 'Geleceƒüe gitmek'],
        ['Asla uyumamak', 'Asla acƒ±kmamak'],
        ['Sƒ±nƒ±rsƒ±z zaman', 'Sƒ±nƒ±rsƒ±z para']
    ];
    const [a, b] = pairs[Math.floor(Math.random() * pairs.length)];
    await message.reply(`ü§î Hangisini se√ßersin?
A) ${a}
B) ${b}`);
}

async function handleShip(message, args) {
    if (args.length < 2) {
        return message.reply('‚õµ Kullanƒ±m: `!ship ki≈üi1 ki≈üi2`');
    }
    const a = args[0];
    const b = args.slice(1).join(' ');
    const score = Math.floor(Math.random() * 101);
    const bar = '‚ù§Ô∏è'.repeat(Math.floor(score / 10)) + 'üñ§'.repeat(10 - Math.floor(score / 10));
    await message.reply(`‚õµ Ship: **${a}** + **${b}** = %${score}
${bar}`);
}

async function handleContentGenerator(message, args) {
    const topic = args.join(' ') || 'komik payla≈üƒ±m';
    const ideas = [
        `"${topic}" i√ßin 10 saniyelik kƒ±sa video: hƒ±zlƒ± zoom + emoji patlamasƒ±`,
        `"${topic}" hakkƒ±nda anket: 4 se√ßenekle arkada≈ülarƒ±nƒ±nƒ± yokla`,
        `"${topic}" ile ilgili mini ske√ß: 3 sahnelik, 30 saniye`,
        `Template: "beklenti vs ger√ßek" - ${topic}`,
        `${topic} i√ßin meme: caption + 2 panel`
    ];
    const idea = ideas[Math.floor(Math.random()*ideas.length)];
    await message.reply(`üìå ƒ∞√ßerik Fikri: ${idea}`);
}

async function handleViralContent(message) {
    const hooks = [
        'Kimse bunu s√∂ylemiyor ama...',
        'Bunu ilk kez payla≈üacaƒüƒ±m...',
        'Sadece %1 ki≈üinin bildiƒüi...',
        'Bu taktikle 10 saniyede...',
        'G√∂z√ºn√º kƒ±rpmadan izle...'
    ];
    const hook = hooks[Math.floor(Math.random()*hooks.length)];
    await message.reply(`üöÄ Viral Ba≈ülangƒ±√ß √ñnerisi: "${hook}"`);
}

async function handleTrendyContent(message) {
    const trends = [
        'POV videolarƒ±', 'Ge√ßi≈ü efektleri', 'Duet/Remix i√ßerikler', 'Storytime akƒ±mlarƒ±', 'Emoji trendleri'
    ];
    const pick = trends[Math.floor(Math.random()*trends.length)];
    await message.reply(`üìà Trend Fikir: **${pick}**`);
}

// Upgrade meme handler with curated SFW sources
async function handleMeme(message, args) {
    try {
        const sources = [
            'https://meme-api.com/gimme/ProgrammerHumor',
            'https://meme-api.com/gimme/memes',
            'https://meme-api.com/gimme/wholesomememes',
            'https://meme-api.com/gimme/dankmemes'
        ];
        const url = sources[Math.floor(Math.random()*sources.length)];
        const { data } = await axios.get(url, { timeout: 8000 });
        const meme = data;
        const embed = new EmbedBuilder()
            .setColor('#FF6B6B')
            .setTitle(meme.title || 'üòÇ Meme')
            .setImage(meme.url)
            .setFooter({ text: meme.author ? `by ${meme.author}` : 'meme-api.com' });
        await message.reply({ embeds: [embed] });
    } catch (e) {
        await message.reply('ü§° Meme bulunamadƒ±, ba≈üka bir ≈üey deneyelim! `!espri` veya `!trend`');
    }
}

// SFW image handlers
async function handleCat(message) {
    try {
        const { data } = await axios.get('https://api.thecatapi.com/v1/images/search', { timeout: 8000 });
        const url = data && data[0] && data[0].url;
        if (!url) throw new Error('no_image');
        const embed = new EmbedBuilder().setColor('#ffb6c1').setTitle('üê± Kedi Zamanƒ±').setImage(url);
        await message.reply({ embeds: [embed] });
    } catch (e) {
        await message.reply('üòø Kedi resmi bulunamadƒ±, tekrar dene!');
    }
}

async function handleDog(message) {
    try {
        const { data } = await axios.get('https://dog.ceo/api/breeds/image/random', { timeout: 8000 });
        const url = data && data.message;
        if (!url) throw new Error('no_image');
        const embed = new EmbedBuilder().setColor('#c0ffee').setTitle('üê∂ K√∂pek Keyfi').setImage(url);
        await message.reply({ embeds: [embed] });
    } catch (e) {
        await message.reply('üêï K√∂pek resmi bulunamadƒ±, tekrar dene!');
    }
}

async function handleWaifuCategory(message, category) {
    try {
        const { data } = await axios.get(`https://api.waifu.pics/sfw/${category}`, { timeout: 8000 });
        const url = data && data.url;
        if (!url) throw new Error('no_image');
        const titles = { waifu: 'üíñ Waifu', neko: 'üêæ Neko', hug: 'ü§ó Sarƒ±lma', kiss: 'üíã √ñp√ºc√ºk', pat: 'ü´∂ Ok≈üama' };
        const embed = new EmbedBuilder().setColor('#9b59b6').setTitle(titles[category] || '‚ú® G√∂rsel').setImage(url);
        await message.reply({ embeds: [embed] });
    } catch (e) {
        await message.reply('üì∑ G√∂rsel alƒ±namadƒ±, tekrar dene!');
    }
}

// NSFW g√∂rsel komutlarƒ± (Admin toggle gerekli)
function nsfwDeniedText() {
    return (
        '‚ö†Ô∏è NSFW i√ßerik bu sunucuda kapalƒ±. Y√∂netici `!nsfwtoggle` ile a√ßabilir.\n' +
        'SFW alternatifler: `!waifu`, `!neko`, `!hug`, `!kiss`, `!patgif`, `!kedi`, `!kopek`'
    );
}

async function handleNSFWImage(message) {
    const isNSFWEnabled = nsfwEnabled.get(message.guild.id) || false;
    if (!isNSFWEnabled) {
        return message.reply(nsfwDeniedText());
    }

    try {
        const response = await axios.get('https://api.waifu.pics/nsfw/waifu');
        const embed = new EmbedBuilder()
            .setColor('#ff6b9d')
            .setTitle('üî• NSFW Waifu')
            .setImage(response.data.url)
            .setFooter({ text: 'NSFW i√ßerik - Sadece 18+ kanallar i√ßin' });
        await message.reply({ embeds: [embed] });
    } catch (error) {
        await message.reply('üö´ NSFW g√∂rsel alƒ±namadƒ±, tekrar dene!');
    }
}

async function handleEroticImage(message) {
    const isNSFWEnabled = nsfwEnabled.get(message.guild.id) || false;
    if (!isNSFWEnabled) {
        return message.reply(nsfwDeniedText());
    }

    try {
        const response = await axios.get('https://api.waifu.pics/nsfw/neko');
        const embed = new EmbedBuilder()
            .setColor('#ff6b9d')
            .setTitle('üíã Erotik G√∂rsel')
            .setImage(response.data.url)
            .setFooter({ text: 'NSFW i√ßerik - Sadece 18+ kanallar i√ßin' });
        await message.reply({ embeds: [embed] });
    } catch (error) {
        await message.reply('üö´ Erotik g√∂rsel alƒ±namadƒ±, tekrar dene!');
    }
}

async function handleHentaiImage(message) {
    const isNSFWEnabled = nsfwEnabled.get(message.guild.id) || false;
    if (!isNSFWEnabled) {
        return message.reply(nsfwDeniedText());
    }

    try {
        const response = await axios.get('https://api.waifu.pics/nsfw/trap');
        const embed = new EmbedBuilder()
            .setColor('#ff6b9d')
            .setTitle('üå∏ Hentai G√∂rsel')
            .setImage(response.data.url)
            .setFooter({ text: 'NSFW i√ßerik - Sadece 18+ kanallar i√ßin' });
        await message.reply({ embeds: [embed] });
    } catch (error) {
        await message.reply('üö´ Hentai g√∂rsel alƒ±namadƒ±, tekrar dene!');
    }
}

async function handleRule34Image(message) {
    const isNSFWEnabled = nsfwEnabled.get(message.guild.id) || false;
    if (!isNSFWEnabled) {
        return message.reply(nsfwDeniedText());
    }

    try {
        const response = await axios.get('https://api.waifu.pics/nsfw/blowjob');
        const embed = new EmbedBuilder()
            .setColor('#ff6b9d')
            .setTitle('üîû Rule34 G√∂rsel')
            .setImage(response.data.url)
            .setFooter({ text: 'NSFW i√ßerik - Sadece 18+ kanallar i√ßin' });
        await message.reply({ embeds: [embed] });
    } catch (error) {
        await message.reply('üö´ Rule34 g√∂rsel alƒ±namadƒ±, tekrar dene!');
    }
}

async function handleNSFWWaifu(message) {
    const isNSFWEnabled = nsfwEnabled.get(message.guild.id) || false;
    if (!isNSFWEnabled) {
        return message.reply(nsfwDeniedText());
    }

    try {
        const categories = ['waifu', 'neko', 'trap'];
        const randomCategory = categories[Math.floor(Math.random() * categories.length)];
        const response = await axios.get(`https://api.waifu.pics/nsfw/${randomCategory}`);
        const embed = new EmbedBuilder()
            .setColor('#ff6b9d')
            .setTitle('üíñ NSFW Waifu')
            .setImage(response.data.url)
            .setFooter({ text: 'NSFW i√ßerik - Sadece 18+ kanallar i√ßin' });
        await message.reply({ embeds: [embed] });
    } catch (error) {
        await message.reply('üö´ NSFW waifu g√∂rsel alƒ±namadƒ±, tekrar dene!');
    }
}

async function handleNSFWNeko(message) {
    const isNSFWEnabled = nsfwEnabled.get(message.guild.id) || false;
    if (!isNSFWEnabled) {
        return message.reply(nsfwDeniedText());
    }

    try {
        const response = await axios.get('https://api.waifu.pics/nsfw/neko');
        const embed = new EmbedBuilder()
            .setColor('#ff6b9d')
            .setTitle('üêæ NSFW Neko')
            .setImage(response.data.url)
            .setFooter({ text: 'NSFW i√ßerik - Sadece 18+ kanallar i√ßin' });
        await message.reply({ embeds: [embed] });
    } catch (error) {
        await message.reply('üö´ NSFW neko g√∂rsel alƒ±namadƒ±, tekrar dene!');
    }
}

async function handleEcchiImage(message) {
    const isNSFWEnabled = nsfwEnabled.get(message.guild.id) || false;
    if (!isNSFWEnabled) {
        return message.reply(nsfwDeniedText());
    }

    try {
        const response = await axios.get('https://api.waifu.pics/nsfw/waifu');
        const embed = new EmbedBuilder()
            .setColor('#ff6b9d')
            .setTitle('‚ú® Ecchi G√∂rsel')
            .setImage(response.data.url)
            .setFooter({ text: 'NSFW i√ßerik - Sadece 18+ kanallar i√ßin' });
        await message.reply({ embeds: [embed] });
    } catch (error) {
        await message.reply('üö´ Ecchi g√∂rsel alƒ±namadƒ±, tekrar dene!');
    }
}
